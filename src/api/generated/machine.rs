// SPDX-License-Identifier: MIT OR Apache-2.0
// DO NOT EDIT
// This file is @generated by prost-build.
/// rpc applyConfiguration
/// ApplyConfiguration describes a request to assert a new configuration upon a
/// node.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplyConfigurationRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "apply_configuration_request::Mode", tag = "4")]
    pub mode: i32,
    #[prost(bool, tag = "5")]
    pub dry_run: bool,
    #[prost(message, optional, tag = "6")]
    pub try_mode_timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `ApplyConfigurationRequest`.
pub mod apply_configuration_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Reboot = 0,
        Auto = 1,
        NoReboot = 2,
        Staged = 3,
        Try = 4,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reboot => "REBOOT",
                Self::Auto => "AUTO",
                Self::NoReboot => "NO_REBOOT",
                Self::Staged => "STAGED",
                Self::Try => "TRY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REBOOT" => Some(Self::Reboot),
                "AUTO" => Some(Self::Auto),
                "NO_REBOOT" => Some(Self::NoReboot),
                "STAGED" => Some(Self::Staged),
                "TRY" => Some(Self::Try),
                _ => None,
            }
        }
    }
}
/// ApplyConfigurationResponse describes the response to a configuration request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfiguration {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Configuration validation warnings.
    #[prost(string, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// States which mode was actually chosen.
    #[prost(enumeration = "apply_configuration_request::Mode", tag = "3")]
    pub mode: i32,
    /// Human-readable message explaining the result of the apply configuration call.
    #[prost(string, tag = "4")]
    pub mode_details: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyConfigurationResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ApplyConfiguration>,
}
/// rpc reboot
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RebootRequest {
    #[prost(enumeration = "reboot_request::Mode", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `RebootRequest`.
pub mod reboot_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Default = 0,
        Powercycle = 1,
        Force = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::Powercycle => "POWERCYCLE",
                Self::Force => "FORCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "POWERCYCLE" => Some(Self::Powercycle),
                "FORCE" => Some(Self::Force),
                _ => None,
            }
        }
    }
}
/// The reboot message containing the reboot status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reboot {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Reboot>,
}
/// rpc Bootstrap
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapRequest {
    /// Enable etcd recovery from the snapshot.
    /// Snapshot should be uploaded before this call via EtcdRecover RPC.
    #[prost(bool, tag = "1")]
    pub recover_etcd: bool,
    /// Skip hash check on the snapshot (etcd).
    /// Enable this when recovering from data directory copy to skip integrity check.
    #[prost(bool, tag = "2")]
    pub recover_skip_hash_check: bool,
}
/// The bootstrap message containing the bootstrap status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bootstrap {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BootstrapResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Bootstrap>,
}
/// rpc events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceEvent {
    #[prost(string, tag = "1")]
    pub sequence: ::prost::alloc::string::String,
    #[prost(enumeration = "sequence_event::Action", tag = "2")]
    pub action: i32,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::common::Error>,
}
/// Nested message and enum types in `SequenceEvent`.
pub mod sequence_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Action {
        Noop = 0,
        Start = 1,
        Stop = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Noop => "NOOP",
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOOP" => Some(Self::Noop),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhaseEvent {
    #[prost(string, tag = "1")]
    pub phase: ::prost::alloc::string::String,
    #[prost(enumeration = "phase_event::Action", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `PhaseEvent`.
pub mod phase_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Action {
        Start = 0,
        Stop = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TaskEvent {
    #[prost(string, tag = "1")]
    pub task: ::prost::alloc::string::String,
    #[prost(enumeration = "task_event::Action", tag = "2")]
    pub action: i32,
}
/// Nested message and enum types in `TaskEvent`.
pub mod task_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Action {
        Start = 0,
        Stop = 1,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceStateEvent {
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    #[prost(enumeration = "service_state_event::Action", tag = "2")]
    pub action: i32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub health: ::core::option::Option<ServiceHealth>,
}
/// Nested message and enum types in `ServiceStateEvent`.
pub mod service_state_event {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Action {
        Initialized = 0,
        Preparing = 1,
        Waiting = 2,
        Running = 3,
        Stopping = 4,
        Finished = 5,
        Failed = 6,
        Skipped = 7,
        Starting = 8,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Initialized => "INITIALIZED",
                Self::Preparing => "PREPARING",
                Self::Waiting => "WAITING",
                Self::Running => "RUNNING",
                Self::Stopping => "STOPPING",
                Self::Finished => "FINISHED",
                Self::Failed => "FAILED",
                Self::Skipped => "SKIPPED",
                Self::Starting => "STARTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INITIALIZED" => Some(Self::Initialized),
                "PREPARING" => Some(Self::Preparing),
                "WAITING" => Some(Self::Waiting),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "FINISHED" => Some(Self::Finished),
                "FAILED" => Some(Self::Failed),
                "SKIPPED" => Some(Self::Skipped),
                "STARTING" => Some(Self::Starting),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestartEvent {
    #[prost(int64, tag = "1")]
    pub cmd: i64,
}
/// ConfigLoadErrorEvent is reported when the config loading has failed.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfigLoadErrorEvent {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// ConfigValidationErrorEvent is reported when config validation has failed.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfigValidationErrorEvent {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
}
/// AddressEvent reports node endpoints aggregated from k8s.Endpoints and network.Hostname.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddressEvent {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MachineStatusEvent reports changes to the MachineStatus resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineStatusEvent {
    #[prost(enumeration = "machine_status_event::MachineStage", tag = "1")]
    pub stage: i32,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<machine_status_event::MachineStatus>,
}
/// Nested message and enum types in `MachineStatusEvent`.
pub mod machine_status_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MachineStatus {
        #[prost(bool, tag = "1")]
        pub ready: bool,
        #[prost(message, repeated, tag = "2")]
        pub unmet_conditions: ::prost::alloc::vec::Vec<machine_status::UnmetCondition>,
    }
    /// Nested message and enum types in `MachineStatus`.
    pub mod machine_status {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UnmetCondition {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub reason: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MachineStage {
        Unknown = 0,
        Booting = 1,
        Installing = 2,
        Maintenance = 3,
        Running = 4,
        Rebooting = 5,
        ShuttingDown = 6,
        Resetting = 7,
        Upgrading = 8,
    }
    impl MachineStage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Booting => "BOOTING",
                Self::Installing => "INSTALLING",
                Self::Maintenance => "MAINTENANCE",
                Self::Running => "RUNNING",
                Self::Rebooting => "REBOOTING",
                Self::ShuttingDown => "SHUTTING_DOWN",
                Self::Resetting => "RESETTING",
                Self::Upgrading => "UPGRADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "BOOTING" => Some(Self::Booting),
                "INSTALLING" => Some(Self::Installing),
                "MAINTENANCE" => Some(Self::Maintenance),
                "RUNNING" => Some(Self::Running),
                "REBOOTING" => Some(Self::Rebooting),
                "SHUTTING_DOWN" => Some(Self::ShuttingDown),
                "RESETTING" => Some(Self::Resetting),
                "UPGRADING" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventsRequest {
    #[prost(int32, tag = "1")]
    pub tail_events: i32,
    #[prost(string, tag = "2")]
    pub tail_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub tail_seconds: i32,
    #[prost(string, tag = "4")]
    pub with_actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<::prost_types::Any>,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
}
/// rpc reset
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResetPartitionSpec {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub wipe: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetRequest {
    /// Graceful indicates whether node should leave etcd before the upgrade, it also
    /// enforces etcd checks before leaving.
    #[prost(bool, tag = "1")]
    pub graceful: bool,
    /// Reboot indicates whether node should reboot or halt after resetting.
    #[prost(bool, tag = "2")]
    pub reboot: bool,
    /// System_partitions_to_wipe lists specific system disk partitions to be reset (wiped).
    /// If system_partitions_to_wipe is empty, all the partitions are erased.
    #[prost(message, repeated, tag = "3")]
    pub system_partitions_to_wipe: ::prost::alloc::vec::Vec<ResetPartitionSpec>,
    /// UserDisksToWipe lists specific connected block devices to be reset (wiped).
    #[prost(string, repeated, tag = "4")]
    pub user_disks_to_wipe: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// WipeMode defines which devices should be wiped.
    #[prost(enumeration = "reset_request::WipeMode", tag = "5")]
    pub mode: i32,
}
/// Nested message and enum types in `ResetRequest`.
pub mod reset_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum WipeMode {
        All = 0,
        SystemDisk = 1,
        UserDisks = 2,
    }
    impl WipeMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "ALL",
                Self::SystemDisk => "SYSTEM_DISK",
                Self::UserDisks => "USER_DISKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALL" => Some(Self::All),
                "SYSTEM_DISK" => Some(Self::SystemDisk),
                "USER_DISKS" => Some(Self::UserDisks),
                _ => None,
            }
        }
    }
}
/// The reset message containing the restart status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reset {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Reset>,
}
/// rpc shutdown
/// The messages message containing the shutdown status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Shutdown {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShutdownRequest {
    /// Force indicates whether node should shutdown without first cordening and draining
    #[prost(bool, tag = "1")]
    pub force: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Shutdown>,
}
/// rpc upgrade
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpgradeRequest {
    #[prost(string, tag = "1")]
    pub image: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub preserve: bool,
    #[prost(bool, tag = "3")]
    pub stage: bool,
    #[prost(bool, tag = "4")]
    pub force: bool,
    #[prost(enumeration = "upgrade_request::RebootMode", tag = "5")]
    pub reboot_mode: i32,
}
/// Nested message and enum types in `UpgradeRequest`.
pub mod upgrade_request {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum RebootMode {
        Default = 0,
        Powercycle = 1,
    }
    impl RebootMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "DEFAULT",
                Self::Powercycle => "POWERCYCLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT" => Some(Self::Default),
                "POWERCYCLE" => Some(Self::Powercycle),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub ack: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Upgrade>,
}
/// rpc servicelist
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceList {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<ServiceInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceList>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub events: ::core::option::Option<ServiceEvents>,
    #[prost(message, optional, tag = "4")]
    pub health: ::core::option::Option<ServiceHealth>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceEvents {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<ServiceEvent>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceEvent {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub ts: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceHealth {
    #[prost(bool, tag = "1")]
    pub unknown: bool,
    #[prost(bool, tag = "2")]
    pub healthy: bool,
    #[prost(string, tag = "3")]
    pub last_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub last_change: ::core::option::Option<::prost_types::Timestamp>,
}
/// rpc servicestart
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceStartRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceStart>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceStopRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStop {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceStopResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceStop>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceRestartRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRestart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub resp: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRestartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ServiceRestart>,
}
/// CopyRequest describes a request to copy data out of Talos node
///
/// Copy produces .tar.gz archive which is streamed back to the caller
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CopyRequest {
    /// Root path to start copying data out, it might be either a file or directory
    #[prost(string, tag = "1")]
    pub root_path: ::prost::alloc::string::String,
}
/// ListRequest describes a request to list the contents of a directory.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRequest {
    /// Root indicates the root directory for the list. If not indicated, '/' is
    /// presumed.
    #[prost(string, tag = "1")]
    pub root: ::prost::alloc::string::String,
    /// Recurse indicates that subdirectories should be recursed.
    #[prost(bool, tag = "2")]
    pub recurse: bool,
    /// RecursionDepth indicates how many levels of subdirectories should be
    /// recursed. The default (0) indicates that no limit should be enforced.
    #[prost(int32, tag = "3")]
    pub recursion_depth: i32,
    /// Types indicates what file type should be returned. If not indicated,
    /// all files will be returned.
    #[prost(enumeration = "list_request::Type", repeated, tag = "4")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// Report xattrs
    #[prost(bool, tag = "5")]
    pub report_xattrs: bool,
}
/// Nested message and enum types in `ListRequest`.
pub mod list_request {
    /// File type.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// Regular file (not directory, symlink, etc).
        Regular = 0,
        /// Directory.
        Directory = 1,
        /// Symbolic link.
        Symlink = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Regular => "REGULAR",
                Self::Directory => "DIRECTORY",
                Self::Symlink => "SYMLINK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REGULAR" => Some(Self::Regular),
                "DIRECTORY" => Some(Self::Directory),
                "SYMLINK" => Some(Self::Symlink),
                _ => None,
            }
        }
    }
}
/// DiskUsageRequest describes a request to list disk usage of directories and regular files
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiskUsageRequest {
    /// RecursionDepth indicates how many levels of subdirectories should be
    /// recursed. The default (0) indicates that no limit should be enforced.
    #[prost(int32, tag = "1")]
    pub recursion_depth: i32,
    /// All write sizes for all files, not just directories.
    #[prost(bool, tag = "2")]
    pub all: bool,
    /// Threshold exclude entries smaller than SIZE if positive,
    /// or entries greater than SIZE if negative.
    #[prost(int64, tag = "3")]
    pub threshold: i64,
    /// DiskUsagePaths is the list of directories to calculate disk usage for.
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// FileInfo describes a file or directory's information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Name is the name (including prefixed path) of the file or directory
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Size indicates the number of bytes contained within the file
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// Mode is the bitmap of UNIX mode/permission flags of the file
    #[prost(uint32, tag = "4")]
    pub mode: u32,
    /// Modified indicates the UNIX timestamp at which the file was last modified
    #[prost(int64, tag = "5")]
    pub modified: i64,
    /// IsDir indicates that the file is a directory
    #[prost(bool, tag = "6")]
    pub is_dir: bool,
    /// Error describes any error encountered while trying to read the file
    /// information.
    #[prost(string, tag = "7")]
    pub error: ::prost::alloc::string::String,
    /// Link is filled with symlink target
    #[prost(string, tag = "8")]
    pub link: ::prost::alloc::string::String,
    /// RelativeName is the name of the file or directory relative to the RootPath
    #[prost(string, tag = "9")]
    pub relative_name: ::prost::alloc::string::String,
    /// Owner uid
    #[prost(uint32, tag = "10")]
    pub uid: u32,
    /// Owner gid
    #[prost(uint32, tag = "11")]
    pub gid: u32,
    /// Extended attributes (if present and requested)
    #[prost(message, repeated, tag = "12")]
    pub xattrs: ::prost::alloc::vec::Vec<Xattr>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Xattr {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// DiskUsageInfo describes a file or directory's information for du command
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskUsageInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// Name is the name (including prefixed path) of the file or directory
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Size indicates the number of bytes contained within the file
    #[prost(int64, tag = "3")]
    pub size: i64,
    /// Error describes any error encountered while trying to read the file
    /// information.
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
    /// RelativeName is the name of the file or directory relative to the RootPath
    #[prost(string, tag = "5")]
    pub relative_name: ::prost::alloc::string::String,
}
/// The messages message containing the requested df stats.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mounts {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<MountStat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Mounts>,
}
/// The messages message containing the requested processes.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MountStat {
    #[prost(string, tag = "1")]
    pub filesystem: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub size: u64,
    #[prost(uint64, tag = "3")]
    pub available: u64,
    #[prost(string, tag = "4")]
    pub mounted_on: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<VersionInfo>,
    #[prost(message, optional, tag = "3")]
    pub platform: ::core::option::Option<PlatformInfo>,
    /// Features describe individual Talos features that can be switched on or off.
    #[prost(message, optional, tag = "4")]
    pub features: ::core::option::Option<FeaturesInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Version>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VersionInfo {
    #[prost(string, tag = "1")]
    pub tag: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sha: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub built: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub go_version: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub arch: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlatformInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mode: ::prost::alloc::string::String,
}
/// FeaturesInfo describes individual Talos features that can be switched on or off.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FeaturesInfo {
    /// RBAC is true if role-based access control is enabled.
    #[prost(bool, tag = "1")]
    pub rbac: bool,
}
/// rpc logs
/// The request message containing the process name.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LogsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "3")]
    pub driver: i32,
    #[prost(bool, tag = "4")]
    pub follow: bool,
    #[prost(int32, tag = "5")]
    pub tail_lines: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// LogsContainer describes all available registered log containers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsContainer {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, repeated, tag = "2")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsContainersResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<LogsContainer>,
}
/// rpc rollback
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RollbackRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollback {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Rollback>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContainersRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "2")]
    pub driver: i32,
}
/// The messages message containing the requested containers.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContainerInfo {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub internal_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub pid: u32,
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub pod_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub network_namespace: ::prost::alloc::string::String,
}
/// The messages message containing the requested containers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub containers: ::prost::alloc::vec::Vec<ContainerInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainersResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Container>,
}
/// dmesg
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DmesgRequest {
    #[prost(bool, tag = "1")]
    pub follow: bool,
    #[prost(bool, tag = "2")]
    pub tail: bool,
}
/// rpc processes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessesResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub processes: ::prost::alloc::vec::Vec<ProcessInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessInfo {
    #[prost(int32, tag = "1")]
    pub pid: i32,
    #[prost(int32, tag = "2")]
    pub ppid: i32,
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub threads: i32,
    #[prost(double, tag = "5")]
    pub cpu_time: f64,
    #[prost(uint64, tag = "6")]
    pub virtual_memory: u64,
    #[prost(uint64, tag = "7")]
    pub resident_memory: u64,
    #[prost(string, tag = "8")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub executable: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub args: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub label: ::prost::alloc::string::String,
}
/// rpc restart
/// The request message containing the process to restart.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestartRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "3")]
    pub driver: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restart {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
/// The messages message containing the restart status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Restart>,
}
/// The request message containing the containerd namespace.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatsRequest {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// driver might be default "containerd" or "cri"
    #[prost(enumeration = "super::common::ContainerDriver", tag = "2")]
    pub driver: i32,
}
/// The messages message containing the requested stats.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub stats: ::prost::alloc::vec::Vec<Stat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Stats>,
}
/// The messages message containing the requested stat.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Stat {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub memory_usage: u64,
    #[prost(uint64, tag = "5")]
    pub cpu_usage: u64,
    #[prost(string, tag = "6")]
    pub pod_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Memory {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub meminfo: ::core::option::Option<MemInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Memory>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MemInfo {
    #[prost(uint64, tag = "1")]
    pub memtotal: u64,
    #[prost(uint64, tag = "2")]
    pub memfree: u64,
    #[prost(uint64, tag = "3")]
    pub memavailable: u64,
    #[prost(uint64, tag = "4")]
    pub buffers: u64,
    #[prost(uint64, tag = "5")]
    pub cached: u64,
    #[prost(uint64, tag = "6")]
    pub swapcached: u64,
    #[prost(uint64, tag = "7")]
    pub active: u64,
    #[prost(uint64, tag = "8")]
    pub inactive: u64,
    #[prost(uint64, tag = "9")]
    pub activeanon: u64,
    #[prost(uint64, tag = "10")]
    pub inactiveanon: u64,
    #[prost(uint64, tag = "11")]
    pub activefile: u64,
    #[prost(uint64, tag = "12")]
    pub inactivefile: u64,
    #[prost(uint64, tag = "13")]
    pub unevictable: u64,
    #[prost(uint64, tag = "14")]
    pub mlocked: u64,
    #[prost(uint64, tag = "15")]
    pub swaptotal: u64,
    #[prost(uint64, tag = "16")]
    pub swapfree: u64,
    #[prost(uint64, tag = "17")]
    pub dirty: u64,
    #[prost(uint64, tag = "18")]
    pub writeback: u64,
    #[prost(uint64, tag = "19")]
    pub anonpages: u64,
    #[prost(uint64, tag = "20")]
    pub mapped: u64,
    #[prost(uint64, tag = "21")]
    pub shmem: u64,
    #[prost(uint64, tag = "22")]
    pub slab: u64,
    #[prost(uint64, tag = "23")]
    pub sreclaimable: u64,
    #[prost(uint64, tag = "24")]
    pub sunreclaim: u64,
    #[prost(uint64, tag = "25")]
    pub kernelstack: u64,
    #[prost(uint64, tag = "26")]
    pub pagetables: u64,
    #[prost(uint64, tag = "27")]
    pub nfsunstable: u64,
    #[prost(uint64, tag = "28")]
    pub bounce: u64,
    #[prost(uint64, tag = "29")]
    pub writebacktmp: u64,
    #[prost(uint64, tag = "30")]
    pub commitlimit: u64,
    #[prost(uint64, tag = "31")]
    pub committedas: u64,
    #[prost(uint64, tag = "32")]
    pub vmalloctotal: u64,
    #[prost(uint64, tag = "33")]
    pub vmallocused: u64,
    #[prost(uint64, tag = "34")]
    pub vmallocchunk: u64,
    #[prost(uint64, tag = "35")]
    pub hardwarecorrupted: u64,
    #[prost(uint64, tag = "36")]
    pub anonhugepages: u64,
    #[prost(uint64, tag = "37")]
    pub shmemhugepages: u64,
    #[prost(uint64, tag = "38")]
    pub shmempmdmapped: u64,
    #[prost(uint64, tag = "39")]
    pub cmatotal: u64,
    #[prost(uint64, tag = "40")]
    pub cmafree: u64,
    #[prost(uint64, tag = "41")]
    pub hugepagestotal: u64,
    #[prost(uint64, tag = "42")]
    pub hugepagesfree: u64,
    #[prost(uint64, tag = "43")]
    pub hugepagesrsvd: u64,
    #[prost(uint64, tag = "44")]
    pub hugepagessurp: u64,
    #[prost(uint64, tag = "45")]
    pub hugepagesize: u64,
    #[prost(uint64, tag = "46")]
    pub directmap4k: u64,
    #[prost(uint64, tag = "47")]
    pub directmap2m: u64,
    #[prost(uint64, tag = "48")]
    pub directmap1g: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostnameResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Hostname>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hostname {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub hostname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadAvgResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<LoadAvg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadAvg {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(double, tag = "2")]
    pub load1: f64,
    #[prost(double, tag = "3")]
    pub load5: f64,
    #[prost(double, tag = "4")]
    pub load15: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemStatResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<SystemStat>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemStat {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(uint64, tag = "2")]
    pub boot_time: u64,
    #[prost(message, optional, tag = "3")]
    pub cpu_total: ::core::option::Option<CpuStat>,
    #[prost(message, repeated, tag = "4")]
    pub cpu: ::prost::alloc::vec::Vec<CpuStat>,
    #[prost(uint64, tag = "5")]
    pub irq_total: u64,
    #[prost(uint64, repeated, tag = "6")]
    pub irq: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "7")]
    pub context_switches: u64,
    #[prost(uint64, tag = "8")]
    pub process_created: u64,
    #[prost(uint64, tag = "9")]
    pub process_running: u64,
    #[prost(uint64, tag = "10")]
    pub process_blocked: u64,
    #[prost(uint64, tag = "11")]
    pub soft_irq_total: u64,
    #[prost(message, optional, tag = "12")]
    pub soft_irq: ::core::option::Option<SoftIrqStat>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CpuStat {
    #[prost(double, tag = "1")]
    pub user: f64,
    #[prost(double, tag = "2")]
    pub nice: f64,
    #[prost(double, tag = "3")]
    pub system: f64,
    #[prost(double, tag = "4")]
    pub idle: f64,
    #[prost(double, tag = "5")]
    pub iowait: f64,
    #[prost(double, tag = "6")]
    pub irq: f64,
    #[prost(double, tag = "7")]
    pub soft_irq: f64,
    #[prost(double, tag = "8")]
    pub steal: f64,
    #[prost(double, tag = "9")]
    pub guest: f64,
    #[prost(double, tag = "10")]
    pub guest_nice: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SoftIrqStat {
    #[prost(uint64, tag = "1")]
    pub hi: u64,
    #[prost(uint64, tag = "2")]
    pub timer: u64,
    #[prost(uint64, tag = "3")]
    pub net_tx: u64,
    #[prost(uint64, tag = "4")]
    pub net_rx: u64,
    #[prost(uint64, tag = "5")]
    pub block: u64,
    #[prost(uint64, tag = "6")]
    pub block_io_poll: u64,
    #[prost(uint64, tag = "7")]
    pub tasklet: u64,
    #[prost(uint64, tag = "8")]
    pub sched: u64,
    #[prost(uint64, tag = "9")]
    pub hrtimer: u64,
    #[prost(uint64, tag = "10")]
    pub rcu: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuFreqStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<CpUsFreqStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpUsFreqStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub cpu_freq_stats: ::prost::alloc::vec::Vec<CpuFreqStats>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CpuFreqStats {
    #[prost(uint64, tag = "1")]
    pub current_frequency: u64,
    #[prost(uint64, tag = "2")]
    pub minimum_frequency: u64,
    #[prost(uint64, tag = "3")]
    pub maximum_frequency: u64,
    #[prost(string, tag = "4")]
    pub governor: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuInfoResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<CpUsInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpUsInfo {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub cpu_info: ::prost::alloc::vec::Vec<CpuInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuInfo {
    #[prost(uint32, tag = "1")]
    pub processor: u32,
    #[prost(string, tag = "2")]
    pub vendor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cpu_family: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub stepping: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub microcode: ::prost::alloc::string::String,
    #[prost(double, tag = "8")]
    pub cpu_mhz: f64,
    #[prost(string, tag = "9")]
    pub cache_size: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub physical_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "11")]
    pub siblings: u32,
    #[prost(string, tag = "12")]
    pub core_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "13")]
    pub cpu_cores: u32,
    #[prost(string, tag = "14")]
    pub apic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub initial_apic_id: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub fpu: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub fpu_exception: ::prost::alloc::string::String,
    #[prost(uint32, tag = "18")]
    pub cpu_id_level: u32,
    #[prost(string, tag = "19")]
    pub wp: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "20")]
    pub flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "21")]
    pub bugs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "22")]
    pub bogo_mips: f64,
    #[prost(uint32, tag = "23")]
    pub cl_flush_size: u32,
    #[prost(uint32, tag = "24")]
    pub cache_alignment: u32,
    #[prost(string, tag = "25")]
    pub address_sizes: ::prost::alloc::string::String,
    #[prost(string, tag = "26")]
    pub power_management: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<NetworkDeviceStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub total: ::core::option::Option<NetDev>,
    #[prost(message, repeated, tag = "3")]
    pub devices: ::prost::alloc::vec::Vec<NetDev>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetDev {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub rx_packets: u64,
    #[prost(uint64, tag = "4")]
    pub rx_errors: u64,
    #[prost(uint64, tag = "5")]
    pub rx_dropped: u64,
    #[prost(uint64, tag = "6")]
    pub rx_fifo: u64,
    #[prost(uint64, tag = "7")]
    pub rx_frame: u64,
    #[prost(uint64, tag = "8")]
    pub rx_compressed: u64,
    #[prost(uint64, tag = "9")]
    pub rx_multicast: u64,
    #[prost(uint64, tag = "10")]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "11")]
    pub tx_packets: u64,
    #[prost(uint64, tag = "12")]
    pub tx_errors: u64,
    #[prost(uint64, tag = "13")]
    pub tx_dropped: u64,
    #[prost(uint64, tag = "14")]
    pub tx_fifo: u64,
    #[prost(uint64, tag = "15")]
    pub tx_collisions: u64,
    #[prost(uint64, tag = "16")]
    pub tx_carrier: u64,
    #[prost(uint64, tag = "17")]
    pub tx_compressed: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<DiskStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskStats {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub total: ::core::option::Option<DiskStat>,
    #[prost(message, repeated, tag = "3")]
    pub devices: ::prost::alloc::vec::Vec<DiskStat>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiskStat {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub read_completed: u64,
    #[prost(uint64, tag = "3")]
    pub read_merged: u64,
    #[prost(uint64, tag = "4")]
    pub read_sectors: u64,
    #[prost(uint64, tag = "5")]
    pub read_time_ms: u64,
    #[prost(uint64, tag = "6")]
    pub write_completed: u64,
    #[prost(uint64, tag = "7")]
    pub write_merged: u64,
    #[prost(uint64, tag = "8")]
    pub write_sectors: u64,
    #[prost(uint64, tag = "9")]
    pub write_time_ms: u64,
    #[prost(uint64, tag = "10")]
    pub io_in_progress: u64,
    #[prost(uint64, tag = "11")]
    pub io_time_ms: u64,
    #[prost(uint64, tag = "12")]
    pub io_time_weighted_ms: u64,
    #[prost(uint64, tag = "13")]
    pub discard_completed: u64,
    #[prost(uint64, tag = "14")]
    pub discard_merged: u64,
    #[prost(uint64, tag = "15")]
    pub discard_sectors: u64,
    #[prost(uint64, tag = "16")]
    pub discard_time_ms: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdLeaveClusterRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdLeaveCluster {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdLeaveClusterResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdLeaveCluster>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdRemoveMemberRequest {
    #[prost(string, tag = "1")]
    pub member: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMember {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRemoveMember>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdRemoveMemberByIdRequest {
    #[prost(uint64, tag = "1")]
    pub member_id: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberById {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRemoveMemberByIdResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRemoveMemberById>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdForfeitLeadershipRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdForfeitLeadership {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub member: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdForfeitLeadershipResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdForfeitLeadership>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdMemberListRequest {
    #[prost(bool, tag = "1")]
    pub query_local: bool,
}
/// EtcdMember describes a single etcd member.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdMember {
    /// member ID.
    #[prost(uint64, tag = "2")]
    pub id: u64,
    /// human-readable name of the member.
    #[prost(string, tag = "3")]
    pub hostname: ::prost::alloc::string::String,
    /// the list of URLs the member exposes to clients for communication.
    #[prost(string, repeated, tag = "4")]
    pub peer_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of URLs the member exposes to the cluster for communication.
    #[prost(string, repeated, tag = "5")]
    pub client_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// learner flag
    #[prost(bool, tag = "6")]
    pub is_learner: bool,
}
/// EtcdMembers contains the list of members registered on the host.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMembers {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// list of member hostnames.
    #[prost(string, repeated, tag = "2")]
    pub legacy_members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// the list of etcd members registered on the node.
    #[prost(message, repeated, tag = "3")]
    pub members: ::prost::alloc::vec::Vec<EtcdMember>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdMemberListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdMembers>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdSnapshotRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRecover {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdRecoverResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdRecover>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmListResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdAlarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarm {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub member_alarms: ::prost::alloc::vec::Vec<EtcdMemberAlarm>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdMemberAlarm {
    #[prost(uint64, tag = "1")]
    pub member_id: u64,
    #[prost(enumeration = "etcd_member_alarm::AlarmType", tag = "2")]
    pub alarm: i32,
}
/// Nested message and enum types in `EtcdMemberAlarm`.
pub mod etcd_member_alarm {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AlarmType {
        None = 0,
        Nospace = 1,
        Corrupt = 2,
    }
    impl AlarmType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Nospace => "NOSPACE",
                Self::Corrupt => "CORRUPT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "NOSPACE" => Some(Self::Nospace),
                "CORRUPT" => Some(Self::Corrupt),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmDisarmResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdAlarmDisarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdAlarmDisarm {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub member_alarms: ::prost::alloc::vec::Vec<EtcdMemberAlarm>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDefragmentResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDefragment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDefragment {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdStatus {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub member_status: ::core::option::Option<EtcdMemberStatus>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdMemberStatus {
    #[prost(string, tag = "11")]
    pub storage_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub member_id: u64,
    #[prost(string, tag = "1")]
    pub protocol_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub db_size: i64,
    #[prost(int64, tag = "3")]
    pub db_size_in_use: i64,
    #[prost(uint64, tag = "4")]
    pub leader: u64,
    #[prost(uint64, tag = "5")]
    pub raft_index: u64,
    #[prost(uint64, tag = "6")]
    pub raft_term: u64,
    #[prost(uint64, tag = "7")]
    pub raft_applied_index: u64,
    #[prost(string, repeated, tag = "8")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "9")]
    pub is_learner: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdDowngradeValidateRequest {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeValidateResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeValidate>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeValidate {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdDowngradeEnableRequest {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeEnableResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeEnable>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeEnable {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeCancelResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<EtcdDowngradeCancel>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EtcdDowngradeCancel {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, optional, tag = "2")]
    pub cluster_downgrade: ::core::option::Option<EtcdClusterDowngrade>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EtcdClusterDowngrade {
    #[prost(string, tag = "1")]
    pub cluster_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RouteConfig {
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gateway: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub metric: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DhcpOptionsConfig {
    #[prost(uint32, tag = "1")]
    pub route_metric: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDeviceConfig {
    #[prost(string, tag = "1")]
    pub interface: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cidr: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub mtu: i32,
    #[prost(bool, tag = "4")]
    pub dhcp: bool,
    #[prost(bool, tag = "5")]
    pub ignore: bool,
    #[prost(message, optional, tag = "6")]
    pub dhcp_options: ::core::option::Option<DhcpOptionsConfig>,
    #[prost(message, repeated, tag = "7")]
    pub routes: ::prost::alloc::vec::Vec<RouteConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub interfaces: ::prost::alloc::vec::Vec<NetworkDeviceConfig>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstallConfig {
    #[prost(string, tag = "1")]
    pub install_disk: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub install_image: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineConfig {
    #[prost(enumeration = "machine_config::MachineType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub install_config: ::core::option::Option<InstallConfig>,
    #[prost(message, optional, tag = "3")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    #[prost(string, tag = "4")]
    pub kubernetes_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MachineConfig`.
pub mod machine_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MachineType {
        TypeUnknown = 0,
        TypeInit = 1,
        TypeControlPlane = 2,
        TypeWorker = 3,
    }
    impl MachineType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TypeUnknown => "TYPE_UNKNOWN",
                Self::TypeInit => "TYPE_INIT",
                Self::TypeControlPlane => "TYPE_CONTROL_PLANE",
                Self::TypeWorker => "TYPE_WORKER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::TypeUnknown),
                "TYPE_INIT" => Some(Self::TypeInit),
                "TYPE_CONTROL_PLANE" => Some(Self::TypeControlPlane),
                "TYPE_WORKER" => Some(Self::TypeWorker),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlPlaneConfig {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CniConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClusterNetworkConfig {
    #[prost(string, tag = "1")]
    pub dns_domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cni_config: ::core::option::Option<CniConfig>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClusterConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub control_plane: ::core::option::Option<ControlPlaneConfig>,
    #[prost(message, optional, tag = "3")]
    pub cluster_network: ::core::option::Option<ClusterNetworkConfig>,
    #[prost(bool, tag = "4")]
    pub allow_scheduling_on_control_planes: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateClientConfigurationRequest {
    /// Roles in the generated client certificate.
    #[prost(string, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Client certificate TTL.
    #[prost(message, optional, tag = "2")]
    pub crt_ttl: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateClientConfiguration {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    /// PEM-encoded CA certificate.
    #[prost(bytes = "vec", tag = "2")]
    pub ca: ::prost::alloc::vec::Vec<u8>,
    /// PEM-encoded generated client certificate.
    #[prost(bytes = "vec", tag = "3")]
    pub crt: ::prost::alloc::vec::Vec<u8>,
    /// PEM-encoded generated client key.
    #[prost(bytes = "vec", tag = "4")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Client configuration (talosconfig) file content.
    #[prost(bytes = "vec", tag = "5")]
    pub talosconfig: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateClientConfigurationResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<GenerateClientConfiguration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketCaptureRequest {
    /// Interface name to perform packet capture on.
    #[prost(string, tag = "1")]
    pub interface: ::prost::alloc::string::String,
    /// Enable promiscuous mode.
    #[prost(bool, tag = "2")]
    pub promiscuous: bool,
    /// Snap length in bytes.
    #[prost(uint32, tag = "3")]
    pub snap_len: u32,
    /// BPF filter.
    #[prost(message, repeated, tag = "4")]
    pub bpf_filter: ::prost::alloc::vec::Vec<BpfInstruction>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BpfInstruction {
    #[prost(uint32, tag = "1")]
    pub op: u32,
    #[prost(uint32, tag = "2")]
    pub jt: u32,
    #[prost(uint32, tag = "3")]
    pub jf: u32,
    #[prost(uint32, tag = "4")]
    pub k: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetstatRequest {
    #[prost(enumeration = "netstat_request::Filter", tag = "1")]
    pub filter: i32,
    #[prost(message, optional, tag = "2")]
    pub feature: ::core::option::Option<netstat_request::Feature>,
    #[prost(message, optional, tag = "3")]
    pub l4proto: ::core::option::Option<netstat_request::L4proto>,
    #[prost(message, optional, tag = "4")]
    pub netns: ::core::option::Option<netstat_request::NetNs>,
}
/// Nested message and enum types in `NetstatRequest`.
pub mod netstat_request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Feature {
        #[prost(bool, tag = "1")]
        pub pid: bool,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct L4proto {
        #[prost(bool, tag = "1")]
        pub tcp: bool,
        #[prost(bool, tag = "2")]
        pub tcp6: bool,
        #[prost(bool, tag = "3")]
        pub udp: bool,
        #[prost(bool, tag = "4")]
        pub udp6: bool,
        #[prost(bool, tag = "5")]
        pub udplite: bool,
        #[prost(bool, tag = "6")]
        pub udplite6: bool,
        #[prost(bool, tag = "7")]
        pub raw: bool,
        #[prost(bool, tag = "8")]
        pub raw6: bool,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NetNs {
        #[prost(bool, tag = "1")]
        pub hostnetwork: bool,
        #[prost(string, repeated, tag = "2")]
        pub netns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "3")]
        pub allnetns: bool,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Filter {
        All = 0,
        Connected = 1,
        Listening = 2,
    }
    impl Filter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "ALL",
                Self::Connected => "CONNECTED",
                Self::Listening => "LISTENING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALL" => Some(Self::All),
                "CONNECTED" => Some(Self::Connected),
                "LISTENING" => Some(Self::Listening),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectRecord {
    #[prost(string, tag = "1")]
    pub l4proto: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub localip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub localport: u32,
    #[prost(string, tag = "4")]
    pub remoteip: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub remoteport: u32,
    #[prost(enumeration = "connect_record::State", tag = "6")]
    pub state: i32,
    #[prost(uint64, tag = "7")]
    pub txqueue: u64,
    #[prost(uint64, tag = "8")]
    pub rxqueue: u64,
    #[prost(enumeration = "connect_record::TimerActive", tag = "9")]
    pub tr: i32,
    #[prost(uint64, tag = "10")]
    pub timerwhen: u64,
    #[prost(uint64, tag = "11")]
    pub retrnsmt: u64,
    #[prost(uint32, tag = "12")]
    pub uid: u32,
    #[prost(uint64, tag = "13")]
    pub timeout: u64,
    #[prost(uint64, tag = "14")]
    pub inode: u64,
    #[prost(uint64, tag = "15")]
    pub r#ref: u64,
    #[prost(uint64, tag = "16")]
    pub pointer: u64,
    #[prost(message, optional, tag = "17")]
    pub process: ::core::option::Option<connect_record::Process>,
    #[prost(string, tag = "18")]
    pub netns: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ConnectRecord`.
pub mod connect_record {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Process {
        #[prost(uint32, tag = "1")]
        pub pid: u32,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum State {
        Reserved = 0,
        Established = 1,
        SynSent = 2,
        SynRecv = 3,
        FinWait1 = 4,
        FinWait2 = 5,
        TimeWait = 6,
        Close = 7,
        Closewait = 8,
        Lastack = 9,
        Listen = 10,
        Closing = 11,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reserved => "RESERVED",
                Self::Established => "ESTABLISHED",
                Self::SynSent => "SYN_SENT",
                Self::SynRecv => "SYN_RECV",
                Self::FinWait1 => "FIN_WAIT1",
                Self::FinWait2 => "FIN_WAIT2",
                Self::TimeWait => "TIME_WAIT",
                Self::Close => "CLOSE",
                Self::Closewait => "CLOSEWAIT",
                Self::Lastack => "LASTACK",
                Self::Listen => "LISTEN",
                Self::Closing => "CLOSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVED" => Some(Self::Reserved),
                "ESTABLISHED" => Some(Self::Established),
                "SYN_SENT" => Some(Self::SynSent),
                "SYN_RECV" => Some(Self::SynRecv),
                "FIN_WAIT1" => Some(Self::FinWait1),
                "FIN_WAIT2" => Some(Self::FinWait2),
                "TIME_WAIT" => Some(Self::TimeWait),
                "CLOSE" => Some(Self::Close),
                "CLOSEWAIT" => Some(Self::Closewait),
                "LASTACK" => Some(Self::Lastack),
                "LISTEN" => Some(Self::Listen),
                "CLOSING" => Some(Self::Closing),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TimerActive {
        Off = 0,
        On = 1,
        Keepalive = 2,
        Timewait = 3,
        Probe = 4,
    }
    impl TimerActive {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "OFF",
                Self::On => "ON",
                Self::Keepalive => "KEEPALIVE",
                Self::Timewait => "TIMEWAIT",
                Self::Probe => "PROBE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "KEEPALIVE" => Some(Self::Keepalive),
                "TIMEWAIT" => Some(Self::Timewait),
                "PROBE" => Some(Self::Probe),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Netstat {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(message, repeated, tag = "2")]
    pub connectrecord: ::prost::alloc::vec::Vec<ConnectRecord>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetstatResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<Netstat>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetaWriteRequest {
    #[prost(uint32, tag = "1")]
    pub key: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaWrite {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaWriteResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<MetaWrite>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetaDeleteRequest {
    #[prost(uint32, tag = "1")]
    pub key: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaDelete {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaDeleteResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<MetaDelete>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageListRequest {
    /// Containerd namespace to use.
    #[prost(enumeration = "super::common::ContainerdNamespace", tag = "1")]
    pub namespace: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageListResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub digest: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub size: i64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImagePullRequest {
    /// Containerd namespace to use.
    #[prost(enumeration = "super::common::ContainerdNamespace", tag = "1")]
    pub namespace: i32,
    /// Image reference to pull.
    #[prost(string, tag = "2")]
    pub reference: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePull {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::common::Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImagePullResponse {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<ImagePull>,
}
/// Generated client implementations.
pub mod machine_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The machine service definition.
    #[derive(Debug, Clone)]
    pub struct MachineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MachineServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MachineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MachineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn apply_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::ApplyConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::ApplyConfigurationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/ApplyConfiguration");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "ApplyConfiguration",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Bootstrap method makes control plane node enter etcd bootstrap mode.
        /// Node aborts etcd join sequence and creates single-node etcd cluster.
        /// If recover_etcd argument is specified, etcd is recovered from a snapshot
        /// uploaded with EtcdRecover.
        pub async fn bootstrap(
            &mut self,
            request: impl tonic::IntoRequest<super::BootstrapRequest>,
        ) -> std::result::Result<tonic::Response<super::BootstrapResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Bootstrap");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Bootstrap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn containers(
            &mut self,
            request: impl tonic::IntoRequest<super::ContainersRequest>,
        ) -> std::result::Result<tonic::Response<super::ContainersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Containers");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Containers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn copy(
            &mut self,
            request: impl tonic::IntoRequest<super::CopyRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Copy");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Copy"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn cpu_freq_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::CpuFreqStatsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/CPUFreqStats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "CPUFreqStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn cpu_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::CpuInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/CPUInfo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "CPUInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disk_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::DiskStatsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/DiskStats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "DiskStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn dmesg(
            &mut self,
            request: impl tonic::IntoRequest<super::DmesgRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Dmesg");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Dmesg"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn events(
            &mut self,
            request: impl tonic::IntoRequest<super::EventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Event>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Events");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Events"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn etcd_member_list(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdMemberListRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdMemberListResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdMemberList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdMemberList"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdRemoveMemberByID removes a member from the etcd cluster identified by member ID.
        /// This API should be used to remove members which don't have an associated Talos node anymore.
        /// To remove a member with a running Talos node, use EtcdLeaveCluster API on the node to be removed.
        pub async fn etcd_remove_member_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdRemoveMemberByIdRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdRemoveMemberByIdResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdRemoveMemberByID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdRemoveMemberByID",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn etcd_leave_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdLeaveClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdLeaveClusterResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdLeaveCluster");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdLeaveCluster",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn etcd_forfeit_leadership(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdForfeitLeadershipRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdForfeitLeadershipResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdForfeitLeadership",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdForfeitLeadership",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdRecover method uploads etcd data snapshot created with EtcdSnapshot
        /// to the node.
        /// Snapshot can be later used to recover the cluster via Bootstrap method.
        pub async fn etcd_recover(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::super::common::Data>,
        ) -> std::result::Result<tonic::Response<super::EtcdRecoverResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdRecover");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdRecover"));
            self.inner.client_streaming(req, path, codec).await
        }
        /// EtcdSnapshot method creates etcd data snapshot (backup) from the local etcd instance
        /// and streams it back to the client.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdSnapshot");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdSnapshot"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// EtcdAlarmList lists etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_alarm_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdAlarmListResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdAlarmList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdAlarmList"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdAlarmDisarm disarms etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_alarm_disarm(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdAlarmDisarmResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdAlarmDisarm");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdAlarmDisarm"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDefragment defragments etcd data directory for the current node.
        /// Defragmentation is a resource-heavy operation, so it should only run on a specific
        /// node.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_defragment(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdDefragmentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdDefragment");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdDefragment"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdStatus returns etcd status for the current member.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_status(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "EtcdStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeValidate validates etcd cluster for downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_validate(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdDowngradeValidateRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeValidateResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/EtcdDowngradeValidate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdDowngradeValidate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeEnable enables etcd cluster downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_enable(
            &mut self,
            request: impl tonic::IntoRequest<super::EtcdDowngradeEnableRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeEnableResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdDowngradeEnable");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdDowngradeEnable",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// EtcdDowngradeCancel cancels etcd cluster downgrade that is in progress.
        /// This method is available only on control plane nodes (which run etcd).
        pub async fn etcd_downgrade_cancel(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeCancelResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/EtcdDowngradeCancel");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "EtcdDowngradeCancel",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn hostname(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::HostnameResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Hostname");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Hostname"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn kubeconfig(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Kubeconfig");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Kubeconfig"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FileInfo>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/List");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "List"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn disk_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::DiskUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DiskUsageInfo>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/DiskUsage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "DiskUsage"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn load_avg(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::LoadAvgResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/LoadAvg");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "LoadAvg"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn logs(
            &mut self,
            request: impl tonic::IntoRequest<super::LogsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Logs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Logs"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn logs_containers(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::LogsContainersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/LogsContainers");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "LogsContainers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn memory(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::MemoryResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Memory");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Memory"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn mounts(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::MountsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Mounts");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Mounts"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn network_device_stats(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::NetworkDeviceStatsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/NetworkDeviceStats");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "NetworkDeviceStats",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn processes(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ProcessesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Processes");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Processes"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Read");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Read"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn reboot(
            &mut self,
            request: impl tonic::IntoRequest<super::RebootRequest>,
        ) -> std::result::Result<tonic::Response<super::RebootResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Reboot");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Reboot"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Restart");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Restart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackRequest>,
        ) -> std::result::Result<tonic::Response<super::RollbackResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Rollback");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Rollback"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reset(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetRequest>,
        ) -> std::result::Result<tonic::Response<super::ResetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Reset");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Reset"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ServiceListResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/ServiceList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceList"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_restart(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceRestartRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceRestartResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/ServiceRestart");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceRestart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_start(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceStartRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceStartResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/ServiceStart");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceStart"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn service_stop(
            &mut self,
            request: impl tonic::IntoRequest<super::ServiceStopRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceStopResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/ServiceStop");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ServiceStop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownRequest>,
        ) -> std::result::Result<tonic::Response<super::ShutdownResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Shutdown");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Shutdown"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<super::StatsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Stats");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Stats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn system_stat(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::SystemStatResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/SystemStat");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "SystemStat"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::UpgradeRequest>,
        ) -> std::result::Result<tonic::Response<super::UpgradeResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Upgrade");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Upgrade"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn version(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::VersionResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Version");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Version"));
            self.inner.unary(req, path, codec).await
        }
        /// GenerateClientConfiguration generates talosctl client configuration (talosconfig).
        pub async fn generate_client_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateClientConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateClientConfigurationResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/machine.MachineService/GenerateClientConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "machine.MachineService",
                "GenerateClientConfiguration",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// PacketCapture performs packet capture and streams back pcap file.
        pub async fn packet_capture(
            &mut self,
            request: impl tonic::IntoRequest<super::PacketCaptureRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::super::common::Data>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/machine.MachineService/PacketCapture");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "PacketCapture"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Netstat provides information about network connections.
        pub async fn netstat(
            &mut self,
            request: impl tonic::IntoRequest<super::NetstatRequest>,
        ) -> std::result::Result<tonic::Response<super::NetstatResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/Netstat");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "Netstat"));
            self.inner.unary(req, path, codec).await
        }
        /// MetaWrite writes a META key-value pair.
        pub async fn meta_write(
            &mut self,
            request: impl tonic::IntoRequest<super::MetaWriteRequest>,
        ) -> std::result::Result<tonic::Response<super::MetaWriteResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/MetaWrite");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "MetaWrite"));
            self.inner.unary(req, path, codec).await
        }
        /// MetaDelete deletes a META key.
        pub async fn meta_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::MetaDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::MetaDeleteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/MetaDelete");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "MetaDelete"));
            self.inner.unary(req, path, codec).await
        }
        /// ImageList lists images in the CRI.
        pub async fn image_list(
            &mut self,
            request: impl tonic::IntoRequest<super::ImageListRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ImageListResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/ImageList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ImageList"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// ImagePull pulls an image into the CRI.
        pub async fn image_pull(
            &mut self,
            request: impl tonic::IntoRequest<super::ImagePullRequest>,
        ) -> std::result::Result<tonic::Response<super::ImagePullResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/machine.MachineService/ImagePull");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("machine.MachineService", "ImagePull"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod machine_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MachineServiceServer.
    #[async_trait]
    pub trait MachineService: std::marker::Send + std::marker::Sync + 'static {
        async fn apply_configuration(
            &self,
            request: tonic::Request<super::ApplyConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::ApplyConfigurationResponse>, tonic::Status>;
        /// Bootstrap method makes control plane node enter etcd bootstrap mode.
        /// Node aborts etcd join sequence and creates single-node etcd cluster.
        /// If recover_etcd argument is specified, etcd is recovered from a snapshot
        /// uploaded with EtcdRecover.
        async fn bootstrap(
            &self,
            request: tonic::Request<super::BootstrapRequest>,
        ) -> std::result::Result<tonic::Response<super::BootstrapResponse>, tonic::Status>;
        async fn containers(
            &self,
            request: tonic::Request<super::ContainersRequest>,
        ) -> std::result::Result<tonic::Response<super::ContainersResponse>, tonic::Status>;
        /// Server streaming response type for the Copy method.
        type CopyStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn copy(
            &self,
            request: tonic::Request<super::CopyRequest>,
        ) -> std::result::Result<tonic::Response<Self::CopyStream>, tonic::Status>;
        async fn cpu_freq_stats(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::CpuFreqStatsResponse>, tonic::Status>;
        async fn cpu_info(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::CpuInfoResponse>, tonic::Status>;
        async fn disk_stats(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::DiskStatsResponse>, tonic::Status>;
        /// Server streaming response type for the Dmesg method.
        type DmesgStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn dmesg(
            &self,
            request: tonic::Request<super::DmesgRequest>,
        ) -> std::result::Result<tonic::Response<Self::DmesgStream>, tonic::Status>;
        /// Server streaming response type for the Events method.
        type EventsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Event, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn events(
            &self,
            request: tonic::Request<super::EventsRequest>,
        ) -> std::result::Result<tonic::Response<Self::EventsStream>, tonic::Status>;
        async fn etcd_member_list(
            &self,
            request: tonic::Request<super::EtcdMemberListRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdMemberListResponse>, tonic::Status>;
        /// EtcdRemoveMemberByID removes a member from the etcd cluster identified by member ID.
        /// This API should be used to remove members which don't have an associated Talos node anymore.
        /// To remove a member with a running Talos node, use EtcdLeaveCluster API on the node to be removed.
        async fn etcd_remove_member_by_id(
            &self,
            request: tonic::Request<super::EtcdRemoveMemberByIdRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdRemoveMemberByIdResponse>, tonic::Status>;
        async fn etcd_leave_cluster(
            &self,
            request: tonic::Request<super::EtcdLeaveClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdLeaveClusterResponse>, tonic::Status>;
        async fn etcd_forfeit_leadership(
            &self,
            request: tonic::Request<super::EtcdForfeitLeadershipRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdForfeitLeadershipResponse>, tonic::Status>;
        /// EtcdRecover method uploads etcd data snapshot created with EtcdSnapshot
        /// to the node.
        /// Snapshot can be later used to recover the cluster via Bootstrap method.
        async fn etcd_recover(
            &self,
            request: tonic::Request<tonic::Streaming<super::super::common::Data>>,
        ) -> std::result::Result<tonic::Response<super::EtcdRecoverResponse>, tonic::Status>;
        /// Server streaming response type for the EtcdSnapshot method.
        type EtcdSnapshotStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// EtcdSnapshot method creates etcd data snapshot (backup) from the local etcd instance
        /// and streams it back to the client.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_snapshot(
            &self,
            request: tonic::Request<super::EtcdSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<Self::EtcdSnapshotStream>, tonic::Status>;
        /// EtcdAlarmList lists etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_alarm_list(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdAlarmListResponse>, tonic::Status>;
        /// EtcdAlarmDisarm disarms etcd alarms for the current node.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_alarm_disarm(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdAlarmDisarmResponse>, tonic::Status>;
        /// EtcdDefragment defragments etcd data directory for the current node.
        /// Defragmentation is a resource-heavy operation, so it should only run on a specific
        /// node.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_defragment(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdDefragmentResponse>, tonic::Status>;
        /// EtcdStatus returns etcd status for the current member.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_status(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdStatusResponse>, tonic::Status>;
        /// EtcdDowngradeValidate validates etcd cluster for downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_downgrade_validate(
            &self,
            request: tonic::Request<super::EtcdDowngradeValidateRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeValidateResponse>, tonic::Status>;
        /// EtcdDowngradeEnable enables etcd cluster downgrade to a specific version.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_downgrade_enable(
            &self,
            request: tonic::Request<super::EtcdDowngradeEnableRequest>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeEnableResponse>, tonic::Status>;
        /// EtcdDowngradeCancel cancels etcd cluster downgrade that is in progress.
        /// This method is available only on control plane nodes (which run etcd).
        async fn etcd_downgrade_cancel(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EtcdDowngradeCancelResponse>, tonic::Status>;
        async fn hostname(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::HostnameResponse>, tonic::Status>;
        /// Server streaming response type for the Kubeconfig method.
        type KubeconfigStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn kubeconfig(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<Self::KubeconfigStream>, tonic::Status>;
        /// Server streaming response type for the List method.
        type ListStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::FileInfo, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn list(
            &self,
            request: tonic::Request<super::ListRequest>,
        ) -> std::result::Result<tonic::Response<Self::ListStream>, tonic::Status>;
        /// Server streaming response type for the DiskUsage method.
        type DiskUsageStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DiskUsageInfo, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn disk_usage(
            &self,
            request: tonic::Request<super::DiskUsageRequest>,
        ) -> std::result::Result<tonic::Response<Self::DiskUsageStream>, tonic::Status>;
        async fn load_avg(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::LoadAvgResponse>, tonic::Status>;
        /// Server streaming response type for the Logs method.
        type LogsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn logs(
            &self,
            request: tonic::Request<super::LogsRequest>,
        ) -> std::result::Result<tonic::Response<Self::LogsStream>, tonic::Status>;
        async fn logs_containers(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::LogsContainersResponse>, tonic::Status>;
        async fn memory(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::MemoryResponse>, tonic::Status>;
        async fn mounts(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::MountsResponse>, tonic::Status>;
        async fn network_device_stats(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::NetworkDeviceStatsResponse>, tonic::Status>;
        async fn processes(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::ProcessesResponse>, tonic::Status>;
        /// Server streaming response type for the Read method.
        type ReadStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<Self::ReadStream>, tonic::Status>;
        async fn reboot(
            &self,
            request: tonic::Request<super::RebootRequest>,
        ) -> std::result::Result<tonic::Response<super::RebootResponse>, tonic::Status>;
        async fn restart(
            &self,
            request: tonic::Request<super::RestartRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartResponse>, tonic::Status>;
        async fn rollback(
            &self,
            request: tonic::Request<super::RollbackRequest>,
        ) -> std::result::Result<tonic::Response<super::RollbackResponse>, tonic::Status>;
        async fn reset(
            &self,
            request: tonic::Request<super::ResetRequest>,
        ) -> std::result::Result<tonic::Response<super::ResetResponse>, tonic::Status>;
        async fn service_list(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::ServiceListResponse>, tonic::Status>;
        async fn service_restart(
            &self,
            request: tonic::Request<super::ServiceRestartRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceRestartResponse>, tonic::Status>;
        async fn service_start(
            &self,
            request: tonic::Request<super::ServiceStartRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceStartResponse>, tonic::Status>;
        async fn service_stop(
            &self,
            request: tonic::Request<super::ServiceStopRequest>,
        ) -> std::result::Result<tonic::Response<super::ServiceStopResponse>, tonic::Status>;
        async fn shutdown(
            &self,
            request: tonic::Request<super::ShutdownRequest>,
        ) -> std::result::Result<tonic::Response<super::ShutdownResponse>, tonic::Status>;
        async fn stats(
            &self,
            request: tonic::Request<super::StatsRequest>,
        ) -> std::result::Result<tonic::Response<super::StatsResponse>, tonic::Status>;
        async fn system_stat(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::SystemStatResponse>, tonic::Status>;
        async fn upgrade(
            &self,
            request: tonic::Request<super::UpgradeRequest>,
        ) -> std::result::Result<tonic::Response<super::UpgradeResponse>, tonic::Status>;
        async fn version(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::VersionResponse>, tonic::Status>;
        /// GenerateClientConfiguration generates talosctl client configuration (talosconfig).
        async fn generate_client_configuration(
            &self,
            request: tonic::Request<super::GenerateClientConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateClientConfigurationResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the PacketCapture method.
        type PacketCaptureStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::super::common::Data, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// PacketCapture performs packet capture and streams back pcap file.
        async fn packet_capture(
            &self,
            request: tonic::Request<super::PacketCaptureRequest>,
        ) -> std::result::Result<tonic::Response<Self::PacketCaptureStream>, tonic::Status>;
        /// Netstat provides information about network connections.
        async fn netstat(
            &self,
            request: tonic::Request<super::NetstatRequest>,
        ) -> std::result::Result<tonic::Response<super::NetstatResponse>, tonic::Status>;
        /// MetaWrite writes a META key-value pair.
        async fn meta_write(
            &self,
            request: tonic::Request<super::MetaWriteRequest>,
        ) -> std::result::Result<tonic::Response<super::MetaWriteResponse>, tonic::Status>;
        /// MetaDelete deletes a META key.
        async fn meta_delete(
            &self,
            request: tonic::Request<super::MetaDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::MetaDeleteResponse>, tonic::Status>;
        /// Server streaming response type for the ImageList method.
        type ImageListStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ImageListResponse, tonic::Status>,
            > + std::marker::Send
            + 'static;
        /// ImageList lists images in the CRI.
        async fn image_list(
            &self,
            request: tonic::Request<super::ImageListRequest>,
        ) -> std::result::Result<tonic::Response<Self::ImageListStream>, tonic::Status>;
        /// ImagePull pulls an image into the CRI.
        async fn image_pull(
            &self,
            request: tonic::Request<super::ImagePullRequest>,
        ) -> std::result::Result<tonic::Response<super::ImagePullResponse>, tonic::Status>;
    }
    /// The machine service definition.
    #[derive(Debug)]
    pub struct MachineServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MachineServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MachineServiceServer<T>
    where
        T: MachineService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/machine.MachineService/ApplyConfiguration" => {
                    #[allow(non_camel_case_types)]
                    struct ApplyConfigurationSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::ApplyConfigurationRequest>
                        for ApplyConfigurationSvc<T>
                    {
                        type Response = super::ApplyConfigurationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ApplyConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::apply_configuration(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ApplyConfigurationSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Bootstrap" => {
                    #[allow(non_camel_case_types)]
                    struct BootstrapSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::BootstrapRequest> for BootstrapSvc<T> {
                        type Response = super::BootstrapResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BootstrapRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::bootstrap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BootstrapSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Containers" => {
                    #[allow(non_camel_case_types)]
                    struct ContainersSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ContainersRequest> for ContainersSvc<T> {
                        type Response = super::ContainersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ContainersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::containers(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ContainersSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Copy" => {
                    #[allow(non_camel_case_types)]
                    struct CopySvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::CopyRequest> for CopySvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::CopyStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CopyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::copy(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CopySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/CPUFreqStats" => {
                    #[allow(non_camel_case_types)]
                    struct CPUFreqStatsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for CPUFreqStatsSvc<T> {
                        type Response = super::CpuFreqStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::cpu_freq_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CPUFreqStatsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/CPUInfo" => {
                    #[allow(non_camel_case_types)]
                    struct CPUInfoSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for CPUInfoSvc<T> {
                        type Response = super::CpuInfoResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::cpu_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CPUInfoSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/DiskStats" => {
                    #[allow(non_camel_case_types)]
                    struct DiskStatsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for DiskStatsSvc<T> {
                        type Response = super::DiskStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::disk_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiskStatsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Dmesg" => {
                    #[allow(non_camel_case_types)]
                    struct DmesgSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::DmesgRequest> for DmesgSvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::DmesgStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DmesgRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::dmesg(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DmesgSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Events" => {
                    #[allow(non_camel_case_types)]
                    struct EventsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::EventsRequest>
                        for EventsSvc<T>
                    {
                        type Response = super::Event;
                        type ResponseStream = T::EventsStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::events(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EventsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdMemberList" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdMemberListSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdMemberListRequest>
                        for EtcdMemberListSvc<T>
                    {
                        type Response = super::EtcdMemberListResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdMemberListRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_member_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdMemberListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdRemoveMemberByID" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdRemoveMemberByIDSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdRemoveMemberByIdRequest>
                        for EtcdRemoveMemberByIDSvc<T>
                    {
                        type Response = super::EtcdRemoveMemberByIdResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdRemoveMemberByIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_remove_member_by_id(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdRemoveMemberByIDSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdLeaveCluster" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdLeaveClusterSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdLeaveClusterRequest>
                        for EtcdLeaveClusterSvc<T>
                    {
                        type Response = super::EtcdLeaveClusterResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdLeaveClusterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_leave_cluster(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdLeaveClusterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdForfeitLeadership" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdForfeitLeadershipSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdForfeitLeadershipRequest>
                        for EtcdForfeitLeadershipSvc<T>
                    {
                        type Response = super::EtcdForfeitLeadershipResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdForfeitLeadershipRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_forfeit_leadership(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdForfeitLeadershipSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdRecover" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdRecoverSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ClientStreamingService<super::super::common::Data>
                        for EtcdRecoverSvc<T>
                    {
                        type Response = super::EtcdRecoverResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::super::common::Data>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_recover(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdRecoverSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdSnapshotSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::EtcdSnapshotRequest>
                        for EtcdSnapshotSvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::EtcdSnapshotStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdAlarmList" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdAlarmListSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for EtcdAlarmListSvc<T> {
                        type Response = super::EtcdAlarmListResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_alarm_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdAlarmListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdAlarmDisarm" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdAlarmDisarmSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for EtcdAlarmDisarmSvc<T> {
                        type Response = super::EtcdAlarmDisarmResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_alarm_disarm(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdAlarmDisarmSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdDefragment" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdDefragmentSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for EtcdDefragmentSvc<T> {
                        type Response = super::EtcdDefragmentResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_defragment(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdDefragmentSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdStatus" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdStatusSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for EtcdStatusSvc<T> {
                        type Response = super::EtcdStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdStatusSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdDowngradeValidate" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdDowngradeValidateSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdDowngradeValidateRequest>
                        for EtcdDowngradeValidateSvc<T>
                    {
                        type Response = super::EtcdDowngradeValidateResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdDowngradeValidateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_downgrade_validate(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdDowngradeValidateSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdDowngradeEnable" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdDowngradeEnableSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::EtcdDowngradeEnableRequest>
                        for EtcdDowngradeEnableSvc<T>
                    {
                        type Response = super::EtcdDowngradeEnableResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EtcdDowngradeEnableRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_downgrade_enable(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdDowngradeEnableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/EtcdDowngradeCancel" => {
                    #[allow(non_camel_case_types)]
                    struct EtcdDowngradeCancelSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for EtcdDowngradeCancelSvc<T> {
                        type Response = super::EtcdDowngradeCancelResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::etcd_downgrade_cancel(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EtcdDowngradeCancelSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Hostname" => {
                    #[allow(non_camel_case_types)]
                    struct HostnameSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for HostnameSvc<T> {
                        type Response = super::HostnameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::hostname(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HostnameSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Kubeconfig" => {
                    #[allow(non_camel_case_types)]
                    struct KubeconfigSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::ServerStreamingService<()> for KubeconfigSvc<T> {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::KubeconfigStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::kubeconfig(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = KubeconfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/List" => {
                    #[allow(non_camel_case_types)]
                    struct ListSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::ListRequest> for ListSvc<T>
                    {
                        type Response = super::FileInfo;
                        type ResponseStream = T::ListStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::list(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/DiskUsage" => {
                    #[allow(non_camel_case_types)]
                    struct DiskUsageSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::DiskUsageRequest>
                        for DiskUsageSvc<T>
                    {
                        type Response = super::DiskUsageInfo;
                        type ResponseStream = T::DiskUsageStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DiskUsageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::disk_usage(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DiskUsageSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/LoadAvg" => {
                    #[allow(non_camel_case_types)]
                    struct LoadAvgSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for LoadAvgSvc<T> {
                        type Response = super::LoadAvgResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::load_avg(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LoadAvgSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Logs" => {
                    #[allow(non_camel_case_types)]
                    struct LogsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::LogsRequest> for LogsSvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::LogsStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::logs(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LogsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/LogsContainers" => {
                    #[allow(non_camel_case_types)]
                    struct LogsContainersSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for LogsContainersSvc<T> {
                        type Response = super::LogsContainersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::logs_containers(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LogsContainersSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Memory" => {
                    #[allow(non_camel_case_types)]
                    struct MemorySvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for MemorySvc<T> {
                        type Response = super::MemoryResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::memory(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MemorySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Mounts" => {
                    #[allow(non_camel_case_types)]
                    struct MountsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for MountsSvc<T> {
                        type Response = super::MountsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::mounts(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MountsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/NetworkDeviceStats" => {
                    #[allow(non_camel_case_types)]
                    struct NetworkDeviceStatsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for NetworkDeviceStatsSvc<T> {
                        type Response = super::NetworkDeviceStatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::network_device_stats(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NetworkDeviceStatsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Processes" => {
                    #[allow(non_camel_case_types)]
                    struct ProcessesSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for ProcessesSvc<T> {
                        type Response = super::ProcessesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::processes(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ProcessesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::ReadRequest> for ReadSvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::ReadStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::read(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Reboot" => {
                    #[allow(non_camel_case_types)]
                    struct RebootSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::RebootRequest> for RebootSvc<T> {
                        type Response = super::RebootResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RebootRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::reboot(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RebootSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Restart" => {
                    #[allow(non_camel_case_types)]
                    struct RestartSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::RestartRequest> for RestartSvc<T> {
                        type Response = super::RestartResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::restart(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Rollback" => {
                    #[allow(non_camel_case_types)]
                    struct RollbackSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::RollbackRequest> for RollbackSvc<T> {
                        type Response = super::RollbackResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RollbackRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::rollback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RollbackSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Reset" => {
                    #[allow(non_camel_case_types)]
                    struct ResetSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ResetRequest> for ResetSvc<T> {
                        type Response = super::ResetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::reset(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ResetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ServiceList" => {
                    #[allow(non_camel_case_types)]
                    struct ServiceListSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for ServiceListSvc<T> {
                        type Response = super::ServiceListResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::service_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ServiceListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ServiceRestart" => {
                    #[allow(non_camel_case_types)]
                    struct ServiceRestartSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::ServiceRestartRequest>
                        for ServiceRestartSvc<T>
                    {
                        type Response = super::ServiceRestartResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServiceRestartRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::service_restart(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ServiceRestartSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ServiceStart" => {
                    #[allow(non_camel_case_types)]
                    struct ServiceStartSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ServiceStartRequest>
                        for ServiceStartSvc<T>
                    {
                        type Response = super::ServiceStartResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServiceStartRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::service_start(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ServiceStartSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ServiceStop" => {
                    #[allow(non_camel_case_types)]
                    struct ServiceStopSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ServiceStopRequest>
                        for ServiceStopSvc<T>
                    {
                        type Response = super::ServiceStopResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServiceStopRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::service_stop(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ServiceStopSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Shutdown" => {
                    #[allow(non_camel_case_types)]
                    struct ShutdownSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ShutdownRequest> for ShutdownSvc<T> {
                        type Response = super::ShutdownResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShutdownRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::shutdown(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShutdownSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Stats" => {
                    #[allow(non_camel_case_types)]
                    struct StatsSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::StatsRequest> for StatsSvc<T> {
                        type Response = super::StatsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as MachineService>::stats(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StatsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/SystemStat" => {
                    #[allow(non_camel_case_types)]
                    struct SystemStatSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for SystemStatSvc<T> {
                        type Response = super::SystemStatResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::system_stat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SystemStatSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Upgrade" => {
                    #[allow(non_camel_case_types)]
                    struct UpgradeSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::UpgradeRequest> for UpgradeSvc<T> {
                        type Response = super::UpgradeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpgradeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::upgrade(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpgradeSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Version" => {
                    #[allow(non_camel_case_types)]
                    struct VersionSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<()> for VersionSvc<T> {
                        type Response = super::VersionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VersionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/GenerateClientConfiguration" => {
                    #[allow(non_camel_case_types)]
                    struct GenerateClientConfigurationSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::UnaryService<super::GenerateClientConfigurationRequest>
                        for GenerateClientConfigurationSvc<T>
                    {
                        type Response = super::GenerateClientConfigurationResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GenerateClientConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::generate_client_configuration(
                                    &inner, request,
                                )
                                .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GenerateClientConfigurationSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/PacketCapture" => {
                    #[allow(non_camel_case_types)]
                    struct PacketCaptureSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::PacketCaptureRequest>
                        for PacketCaptureSvc<T>
                    {
                        type Response = super::super::common::Data;
                        type ResponseStream = T::PacketCaptureStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PacketCaptureRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::packet_capture(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PacketCaptureSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/Netstat" => {
                    #[allow(non_camel_case_types)]
                    struct NetstatSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::NetstatRequest> for NetstatSvc<T> {
                        type Response = super::NetstatResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetstatRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::netstat(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NetstatSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/MetaWrite" => {
                    #[allow(non_camel_case_types)]
                    struct MetaWriteSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::MetaWriteRequest> for MetaWriteSvc<T> {
                        type Response = super::MetaWriteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MetaWriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::meta_write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MetaWriteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/MetaDelete" => {
                    #[allow(non_camel_case_types)]
                    struct MetaDeleteSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::MetaDeleteRequest> for MetaDeleteSvc<T> {
                        type Response = super::MetaDeleteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MetaDeleteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::meta_delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MetaDeleteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ImageList" => {
                    #[allow(non_camel_case_types)]
                    struct ImageListSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService>
                        tonic::server::ServerStreamingService<super::ImageListRequest>
                        for ImageListSvc<T>
                    {
                        type Response = super::ImageListResponse;
                        type ResponseStream = T::ImageListStream;
                        type Future =
                            BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImageListRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::image_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ImageListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/machine.MachineService/ImagePull" => {
                    #[allow(non_camel_case_types)]
                    struct ImagePullSvc<T: MachineService>(pub Arc<T>);
                    impl<T: MachineService> tonic::server::UnaryService<super::ImagePullRequest> for ImagePullSvc<T> {
                        type Response = super::ImagePullResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImagePullRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::image_pull(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ImagePullSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(
                        http::header::CONTENT_TYPE,
                        tonic::metadata::GRPC_CONTENT_TYPE,
                    );
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for MachineServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "machine.MachineService";
    impl<T> tonic::server::NamedService for MachineServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
