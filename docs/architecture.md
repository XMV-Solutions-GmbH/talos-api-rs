# Architecture

## Directory Structure

```text
talos-api-rs/
├── src/
│   ├── lib.rs              # Crate root, public exports
│   ├── client/
│   │   ├── mod.rs          # TalosClient, TalosClientConfig
│   │   └── tests.rs        # Unit tests
│   ├── api/
│   │   ├── mod.rs          # API module exports
│   │   └── generated/      # Protobuf-generated code (DO NOT EDIT)
│   │       ├── mod.rs
│   │       ├── version.rs
│   │       ├── machine.rs
│   │       ├── common.rs
│   │       └── google.rpc.rs
│   ├── error/
│   │   └── mod.rs          # TalosError enum
│   └── testkit/
│       └── mod.rs          # TalosCluster for integration tests
├── proto/
│   ├── common/
│   │   ├── version.proto
│   │   └── common.proto
│   ├── machine/
│   │   └── machine.proto
│   └── google/rpc/
│       └── status.proto
├── examples/
│   ├── version.rs
│   └── machine.rs
├── tests/
│   └── integration_test.rs
├── docs/
│   ├── app-concept.md
│   ├── architecture.md
│   ├── testing.md
│   └── todo.md
└── build.rs                # Protobuf compilation
```

## Layers

### 1. Transport Layer (client/)

Handles TLS/mTLS, connection management, and channel creation.

```rust
TalosClientConfig {
    endpoint: String,       // e.g., "https://127.0.0.1:50000"
    crt_path: Option<String>,
    key_path: Option<String>,
    ca_path: Option<String>,
    insecure: bool,         // Skip TLS verification
}
```

**Key Components**:

- `TalosClient::new()` - Async constructor with TLS setup
- `NoVerifier` - Custom rustls verifier for insecure mode
- Custom `tower::service_fn` connector for manual TLS handling

**Current Limitations**:

- ED25519 certificates not fully supported (see Known Issues in app-concept.md)
- Single-endpoint only (no multi-node targeting yet)

### 2. API Layer (api/)

Pure generated code from Protobuf. **NEVER EDIT MANUALLY**.

**Generated Clients**:

- `VersionServiceClient` - Health/version checks
- `MachineServiceClient` - Machine operations (60+ methods)

**Access Pattern**:

```rust
let client = TalosClient::new(config).await?;
let mut version = client.version();
let mut machine = client.machine();
```

### 3. Error Layer (error/)

Structured error handling.

```rust
pub enum TalosError {
    Config(String),
    Transport(tonic::transport::Error),
    Grpc(tonic::Status),
}
```

### 4. Test Infrastructure (testkit/)

Integration test harness using Docker-based Talos clusters.

```rust
pub struct TalosCluster {
    pub name: String,
    pub endpoint: String,
    pub talosconfig_path: PathBuf,
    pub ca_path: PathBuf,
    pub crt_path: PathBuf,
    pub key_path: PathBuf,
}
```

**Workflow**:

1. `TalosCluster::create()` - Provisions cluster via `talosctl cluster create docker`
2. Extracts certificates from generated talosconfig
3. Provides endpoint for client testing
4. `Drop` implementation destroys cluster automatically

## Data Flow

```text
User Code
    │
    ▼
TalosClient (holds tonic::Channel)
    │
    ▼
MachineServiceClient<Channel> (generated by tonic)
    │
    ▼
tonic::Channel (HTTP/2 + TLS via rustls)
    │
    ▼
Talos API (gRPC on port 50000, requires mTLS)
```

## TLS Configuration

### Standard mTLS Mode

```rust
let mut tls = ClientTlsConfig::new();
tls = tls.ca_certificate(Certificate::from_pem(ca_pem));
tls = tls.identity(Identity::from_pem(cert_pem, key_pem));
channel_builder = channel_builder.tls_config(tls)?;
```

### Insecure Mode

For testing where TLS verification should be skipped:

- Uses custom rustls connector with `NoVerifier`
- Still encrypted, but no certificate verification
- Talos rejects connection (requires mTLS)

## Testing Strategy

### Unit Tests

- Mock gRPC servers using tonic
- No external dependencies
- Fast execution

### Integration Tests

- Require `TALOS_DEV_TESTS=1`
- Provision real Docker-based Talos cluster
- Automatic cleanup via Drop
